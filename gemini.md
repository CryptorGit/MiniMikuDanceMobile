# MiniMikuDance 詳細設計書 (最終版)

## 1. 概要
本ドキュメントは、モバイルアプリケーション「MiniMikuDance」のコア機能（モデル読み込み、IK、物理演算）に関する、実装可能なレベルの詳細設計を定義する。`codex.md`のアーキテクチャ的視点と、`gemini.md`のアルゴリズム的視点を統合し、高品質で拡張性の高いアプリケーション開発の礎とすることを目的とする。

---

## 2. プロジェクト要件と制約

- **エンコーディング**: VMDファイルのモーション・モデル名はShift-JISでエンコードされている。クロスプラットフォームな.NET環境でこれを扱うため、`System.Text.Encoding.CodePages` NuGetパッケージを導入し、`CodePagesEncodingProvider`を登録する必要がある。
- **エラーハンドリング方針**: アプリケーションの安定性を最優先とする。PMX/VMDファイル内の未対応機能（例: ソフトボディ、一部のモーフ）や軽微なフォーマット違反は、エラーで処理を中断するのではなく、警告ログを出力して安全にスキップする。これにより、可能な限り多くのモデル・モーション資産との互換性を確保する。
- **外部依存**: 物理演算には`bepuphysics2`を採用する。ネイティブライブラリへの依存がなく、クロスプラットフォーム展開が容易であるため。詳細は「4.3. 物理演算モジュール」で後述する。

---

## 3. 統合アーキテクチャ

### 3.1. モジュール構成とAPI設計
各主要機能をインターフェースとして抽象化し、モジュール間の依存を疎に保つ。これにより、将来的な機能改善やテストが容易になる。

- **`IImporter`**: モデルとモーションの読み込み責務を負う。
    - `MmdModel LoadModel(string path)`
    - `MmdMotion LoadMotion(string path)`

- **`IAnimator`**: モデルとモーションを結びつけ、フレーム単位のアニメーションを適用する。
    - `void Apply(MmdModel model, MmdMotion motion, float frame)`

- **`IIkSolver`**: IKチェーンの解決責務を負う。
    - `void Solve(MmdModel model)`

- **`IPhysicsEngine`**: 物理シミュレーションの責務を負う。
    - `void Setup(MmdModel model)`
    - `void Step(float deltaTime)`
    - `bool Raycast(Vector3 origin, Vector3 direction, float maxDistance, out RayHit hit)`

### 3.2. 座標系と単位の統一
- **座標系**: 右手座標系、Y-upを基準とする。PMXの座標系はこれと一致するが、他のシステムと連携する際は変換層を設ける可能性がある。
- **単位**: 1 unit = 8m。MMD標準の単位系に合わせる。物理演算のパラメータ（重力など）はこのスケールに合わせて調整する。

### 3.3. 統合更新ループ
毎フレーム、以下の厳密な順序でモデルの状態を更新する。この順序は、変形結果が後続の処理に正しく影響を及ぼすために不可欠である。

1.  **入力 (アニメーション適用)**: `IAnimator.Apply()` を呼び出し、指定フレームのボーンのローカル変形（位置・回転）とモーフのウェイトを適用する。
2.  **ボーン行列更新 (1回目)**: 親から子へ、全ボーンのワールド行列を計算する。
3.  **物理演算**: `IPhysicsEngine.Step()` を呼び出す。
    a. (Pre-Step) キネマティック剛体の追従（アニメーションされたボーンの動きを物理ワールドに反映）。
    b. (Simulate) 物理シミュレーションの実行。
    c. (Post-Step) 物理演算剛体の結果をボーンのワールド行列に上書き。
4.  **物理演算結果のローカル反映**: 物理演算の影響を受けたボーンについて、更新されたワールド行列と親のワールド行列から、自身のローカル回転・位置を再計算する。
5.  **IK解決**: `IIkSolver.Solve()` を呼び出す。IKは物理演算後のボーン状態に対して適用される。
6.  **ボーン行列更新 (最終)**: IK解決の結果を反映し、再度全ボーンのワールド行列を計算する。この最終的な行列がレンダリングに使用される。

---

## 4. モジュール別 詳細設計

### 4.1. Importerモジュール (`IImporter`実装)
(以前の詳細設計に同じ。`ModelLoader`, `MotionLoader`を内部に持ち、`IImporter`インターフェースを実装する)

### 4.2. IKモジュール (`IIkSolver`実装)

#### `IkSolver` クラス
- **`Solve(MmdModel model)`**: モデル内の全IK定義を解決する。
    1. `model.IkChains` を走査し、通常のIKチェーンを解決する (`SolveCcdChain`)。
    2. `model.FootIkChains` を走査し、フットIKを解決する (`SolveFootIk`)。

#### `SolveCcdChain` (プライベートメソッド)
(以前の詳細設計に同じ。CCDアルゴリズムを実装)

#### `SolveFootIk` (プライベートメソッド) - (`codex.md`より導入)
**目的**: 足が地面に正しく接地するように、足首のIKターゲット位置を動的に調整する。

**ロジック**:
1.  **現在の足首位置を取得**: IKチェーンのターゲットである足首ボーンのワールド座標 `anklePosition` を取得する。
2.  **レイキャストによる地面検知**:
    a. `anklePosition` の真上から真下に向けてレイを定義: `origin = anklePosition + new Vector3(0, 0.5f, 0)`, `direction = new Vector3(0, -1, 0)`。
    b. `IPhysicsEngine.Raycast(origin, direction, 1.0f, out RayHit hit)` を呼び出す。
3.  **IKターゲットの調整**:
    a. レイが地面にヒットした場合 (`hit.HasHit`):
        - 新しいIKターゲット位置を `hit.Position` とする。
        - (オプション) `hit.Normal` を用いて、足首のIKターゲットの回転も調整し、足が地面の傾斜に沿うようにする。
    b. ヒットしなかった場合:
        - 元々の `anklePosition` をIKターゲットとして使用する。
4.  **調整後のターゲットでCCD解決**: 調整された新しいIKターゲット位置を用いて、この足のIKチェーンに対して `SolveCcdChain` を呼び出す。
5.  **(オプション) ルートボーン補正**: 地面が高すぎる場合、膝が極端に曲がるのを防ぐため、モデルのルートボーン（全ての親）を僅かに上方へ移動させるヒューリスティックを適用する。

#### IKチェーンの胸部拡張 - (`codex.md`より導入)
`SolveCcdChain` の反復ループ内で、ターゲットへの到達度が低い（距離が閾値以下に収束しない）場合、一時的にIKリンクのルートを親方向（脊椎、胸部ボーン）へ拡張し、数回追加の反復処理を行う。これにより、腕を大きく伸ばすようなポーズの自然さが向上する。

### 4.3. 物理演算モジュール (`IPhysicsEngine`実装)

#### `BepuPhysicsEngine` クラス
`bepuphysics2`をラップし、`IPhysicsEngine`を実装する。
(以前の詳細設計に同じ。`PhysicsManager`のロジックを本クラスに実装)

#### 技術選定: BepuPhysics v2 vs BulletSharp - (`codex.md`より導入)
- **BepuPhysics v2**: ピュアC#実装であり、ネイティブライブラリの配布やプラットフォームごとのビルドが不要。モバイル展開において大きな利点となる。パフォーマンスも高く、現代的なAPIを持つ。本プロジェクトではこちらを優先的に採用する。
- **BulletSharp**: C++のBullet Physicsへのラッパー。歴史が長くUnityでの採用実績も豊富だが、ネイティブコードへの依存がモバイル展開の複雑性を増大させるため、今回は採用を見送る。

#### 安定化手法: サブステップ実行 - (`codex.md`より導入)
`Step`メソッド内部で、`deltaTime`が特定の閾値（例: 1/60秒）を超えた場合、`_simulation.Timestep()`を複数回に分けて呼び出す（サブステップ実行）。これにより、低フレームレート時でも物理演算が破綻するのを防ぎ、シミュレーションの安定性を確保する。

---

## 5. モバイル最適化戦略

- **ストリーミングI/O**: `IImporter`の実装において、モデルやモーションファイルを一度に全てメモリに読み込むのではなく、ストリームから逐次解析することで、読み込み時のピークメモリ使用量を削減する。
- **動的な複雑度調整**: アプリケーションの負荷に応じて、IKの反復回数や物理演算のソルバーのイテレーション数を動的に変更するAPIを設ける。例えば、多数のキャラクターが同時に表示される場合は、これらの値を下げてフレームレートを維持する。
- **メモリプーリング**: `bepuphysics2`が内部で利用する`BufferPool`をアプリケーション全体で共有・再利用し、GCの発生を抑制する。

---

## 6. エラーハンドリングと互換性

- **未対応データの安全なスキップ**: `IImporter`は、PMX/VMD仕様のうち、本アプリで対応しない機能（例: ソフトボディ、QDEFスキニング、一部の特殊モーフ）を検出した場合、警告ログを出力した上で、該当データを無視して読み込み処理を継続する。
- **インデックス範囲チェック**: ファイル内のボーンインデックス等がモデルの要素数を超えている場合、不正なインデックスとして扱い、関連する処理（IKリンク、剛体など）を無効化する。これにより、メモリアクセス違反によるクラッシュを防止する。