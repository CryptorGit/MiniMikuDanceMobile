モバイル環境でのMMD再現 (OpenTK + PMXParser + BEPUphysics v2)
はじめに
モバイルアプリ上でMikuMikuDance (MMD)のような3Dキャラクターのアニメーションと物理挙動を再現するには、モデル・モーションデータの読み込み、物理エンジンとの同期、描画パフォーマンスといった複数の課題を統合的に解決する必要があります。本稿では、OpenTK（OpenGL ES 3.0対応）による描画、PMXParser（C#製のMMDモデル/モーションローダー）によるPMXモデルおよびVMDモーションの取り扱い、そして純C#製物理エンジンであるBEPUphysics v2を組み合わせる手法について、既存の事例や技術構成を詳述します。特に物理演算の同期や描画パフォーマンス上の注意点に着目し、各ライブラリを正しく連携させる方法と考慮点を整理します。
関連プロジェクトと事例
MMDモデルの独自実行環境については、既にいくつかの事例があります。代表的なものに、C++で実装されたMMDビューワ「Saba」があります[1]。SabaはOpenGLを使用し、PMD/PMXモデルとVMDモーションに対応、Bullet Physicsによる物理シミュレーションも実装しています[2]。ただしBulletによる計算結果は本家MMDと完全には一致しない場合もある旨が報告されています[3]。これは物理エンジンやパラメータの差異によるものですが、MMD環境を再現する上で物理結果の差異は避けがたい課題です。
Sabaを基にしたオープンソースMMDプレイヤーの実行例（SabaSharp）では、モデルの描画と剛体物理を組み合わせてMMDアニメーションを再現している。このような自作レンダラーではBulletなどの物理エンジン統合が行われている[4][5]
C#環境にも同様の試みが存在します。たとえば SabaSharp は上記Sabaの実装を参考に、.NET上に移植したクロスプラットフォーム対応のMMDレンダラーです[6]。SabaSharpではOpenGL ESによる描画基盤やOpenCLによるスキニング計算の最適化が導入されており、Bullet Physics（Evergine.Bulletによるバインディング）を用いてMMDモデルの物理演算を再現しています[4]。一方、本稿で扱う構成ではBulletではなくBEPUphysics v2を採用します。BEPUphysicsはC#製の高速な剛体物理エンジンであり、最新のv2では前バージョンの約10倍もの性能向上が達成されたとの報告もあります[7]。Bulletのようなネイティブライブラリと違い、純C#実装のBEPUphysics v2はモバイルを含むマルチプラットフォームで扱いやすく、ガベージコレクションやマルチスレッドにも最適化されています。
以上のプロジェクトから得られる示唆は、(1) MMDモデルフォーマット（PMX/VMD）の正確なパースとデータ構造への取り込み、(2) 物理エンジンへのボーン・剛体データのマッピングとシミュレーション結果のモデルへの反映、(3) GPU描画パイプラインへのスムーズなデータ転送と最適化――の三点が成功の鍵だということです[8][9]。以下、これらポイントを軸に技術的構成を解説します。
PMXモデル・VMDモーションの読み込みとデータ構造
PMXParserライブラリを用いることで、MMDモデルファイル(.pmx)を解析し、モデルデータをC#オブジェクトとして取得できます。PMXには頂点座標、法線、UV、ボーン階層、スキニングウェイト、剛体（Rigid Body）やジョイント（関節）情報など、モデルを構成するためのあらゆる要素が含まれます[10]。PMXParserはこれらを読み取り、頂点配列やボーンリスト、剛体リスト等の構造体に格納します。VMDファイル（モーションデータ）についても、対応するパーサを用いて読み込むか、PMXParserの派生/関連機能で取り込む必要があります（PMXParser自体はモーション非対応のため、別途VMDのパース処理を実装するか既存ツールを利用します）。
読み込んだデータは内部の管理クラスへマッピングします。例えばCNBlogsの事例では、PmxModelクラスにモデル構造、MMDModelクラスに描画用データや状態、VmdAnimationおよびAnimationControllerでモーション状態を管理する、といった分離をしています[8]。これにより、モデルデータ（メッシュ・ボーン）とアニメーションデータを明確に分離しつつ、それらを統合して扱える設計となります。
ボーンとIK（Inverse Kinematics）の取り扱い: MMDのモデルボーンは階層構造を持ち、各ボーンには初期位置・回転、親子関係、さらにIK目標が定義されている場合があります。PMXParserから得たボーン情報を用いてボーン階層を再構築し、各ボーンのローカル変換行列を持つツリーを用意します。VMDモーションを適用する際は、各フレームに対して指定されたボーンの回転・移動量をボーン行列に適用します。その際、モーション補間は滑らかに行う必要があります。MMDでは球面線形補間（Slerp）によってボーン回転の補間が行われ、キーフレーム間の動きを滑らかにつないでいます[11]。実装上も線形補間ではなく四元数Slerpやベジエ補間（VMDに含まれる補間曲線データを利用）を行うことで、カクカクした不自然な動きを防ぎます[12]。
特に脚などに使われるIKについては、CCD法 (Cyclic Coordinate Descent) を用いて目標位置に収束させるのがMMD標準です[13]。MMDモデルのIK設定には「ループ回数上限」が含まれており、例えば一般的な足IKでは 最大30回程度 の反復で計算を打ち切る設定になっています[14]。実際の実装でも各IKチェーンについてこの上限回数までCCD反復を行い、十分目標に近づいたところで終了します。こうした上限設定に倣うことで、計算量を制御しつつ必要十分な精度を確保できます[14]。IK解決はモーション適用後、物理演算の前に行います。すなわちフレーム毎に、まずキーフレームに基づきボーン姿勢を更新し（補間込み）、次にIKソルバで足等の姿勢を調整します。この順序を守ることで、物理シミュレーションに入る前にキャラクターの論理的なポーズが完成します。
BEPUphysics v2による物理エンジン統合
剛体とジョイントの生成: PMXには剛体(Rigid Body)およびジョイント(Joint)の設定が含まれ、モデルの物理挙動を定義しています。これらの情報をBEPUphysics v2に渡すことで、物理シミュレーションを再現可能です。まずPMXの剛体データを調査し、それぞれに以下の属性があることを確認します[15][16]:
•	関連ボーン: 剛体に対応づけられたボーン。[17]ボーンとの関係により、剛体の種類に応じた挙動が決まります（後述）。
•	剛体タイプ: PMXでは3種類が統合的に表現されています[18]:
•	ボーン追従: 物理シミュレーションを行わない剛体。指定ボーンに剛体が固定されて動き、主に当たり判定用の静的コリジョンとして機能します[19]。
•	物理演算: 物理シミュレーションの対象となる動的剛体。このタイプがシミュレーションにおける主役で、重力や衝突の影響を受け自由に動きます[20]。
•	ボーン位置合わせ（物理+ボーン位置合わせ）: 動的剛体の一種で、シミュレーション後にボーンとの位置を調整するフラグです[21]。ジョイント制限を無視して剛体が動いてしまう場合などに、最終的にボーン位置に剛体を戻す目的で使われます[21]。PMX上は「物理演算」タイプにこのフラグを付与する形で表現されています。
•	形状・サイズ・オフセット: 剛体の当たり判定形状（球、箱、カプセル）と寸法、およびボーンに対するオフセット位置。[22]
•	物理パラメータ: 質量、移動減衰、回転減衰、反発力（反射係数）、摩擦係数など[23][24]。
これらのデータに基づき、BEPUphysics側で剛体を生成します。ボーン追従剛体については、シミュレーションに参加させつつも動かないキネマティック剛体として扱います（質量無限大あるいは運動を外部制御）。具体的には、BEPUで剛体を作成した後 Body.IsKinematic = true や質量0を設定し、毎フレームその剛体の位置を対応するボーンの変換に上書きします。こうすることで、剛体自体は物理演算の影響を受けず（固定され）、他の動的剛体との衝突判定には寄与する「固定オブジェクト」となります。例えば頭部や体幹に対応する剛体はボーン追従として設定され、髪やスカートの剛体がそれに衝突して押し出される、といった振る舞いになります[17][25]。
一方、物理演算剛体はBEPUphysics上で動的剛体（Dynamic Body）として生成し、シミュレーション空間（Space/Simulation）に追加します。PMX指定の質量や減衰係数（剛体の抵抗）、反発力や摩擦係数も、BEPUの剛体プロパティに反映します[23][24]。例えば髪の毛先の剛体は質量を小さく、減衰を弱め（よく動くように）、反発力0（衝突しても跳ね返らない）といった設定になっているので、BEPU上でも同様にセットします。物理+ボーン位置合わせフラグ付きの剛体についても基本は動的剛体ですが、後述のようにシミュレーション後にボーン位置へ戻す処理を行うことで挙動を安定させます[21]。
次にジョイント（関節）です。PMXジョイントは2つの剛体間の拘束条件（6軸の並進・回転それぞれの制限範囲およびバネ係数）を定義しています。これに対応するよう、BEPUphysics v2で二剛体間の制約を設定します。例えば、「剛体AとBの相対的な位置をあるアンカー点で固定し、回転は特定軸のみ許容し他軸は制限する」というジョイントであれば、BEPUでは以下のように構成できます:
•	位置拘束: BEPUのBallSocketJoint（玉掛けジョイント）等を用い、2剛体の指定アンカー点同士を一致させます。これによりジョイント位置で剛体同士が繋がります。
•	回転拘束: BEPUには多様な角度制約がありますが、例えばヒンジ（蝶番）ジョイントによる1軸回転のみ許可、他軸はAngularLimit（角度制限）やTwistLimitで範囲を制限、といった組み合わせでPMXの回転制限を再現します[26]。MMDジョイントの設定値（各軸の最大回転角など）をBEPUの制約オブジェクトに適用して、必要な可動域に収めます。また並進の制限についても、DistanceLimit等で2剛体の相対移動量を制限できます。
BEPUphysics v2は標準で多数の制約タイプを備えており[27]、必要に応じて複合的に組み合わせることで6自由度の拘束を表現できます。例えばMMDでよく使われる「スプリング付き6DOFジョイント」に近い挙動は、BallSocketJoint＋AngularLimits＋ばね要素（SoftLimitやServo機能を利用）で再現可能です。各ジョイントについて、PMXのパラメータ（移動制限範囲、回転制限範囲、バネ定数）を反映するよう調整します。
衝突グループとフィルタ: MMDでは剛体ごとにグループと非衝突グループが設定されており、特定の剛体同士の衝突判定を無効化できます[25]。例えば同じスカート内の剛体同士は干渉しないようにしたり、キャラクターの脚とスカート外側だけ衝突させスカート内側とは衝突させない、等の細かい調整です[28]。BEPUでもコリジョンフィルタ機能（剛体にビットマスクグループを割り当て、特定の組み合わせを無視する設定）を利用して、PMXの非衝突グループ設定を再現します。これにより不要な自己衝突による暴発を防ぎ、想定通りの部分だけがぶつかるシミュレーションになります。
更新ループとデータ同期: すべての構成要素を準備したら、毎フレームでの更新処理を正しい順序で行うことが肝要です。典型的なフレーム更新順序は次のとおりです[5]:
1.	アニメーション適用: VMDの該当フレームのボーン姿勢を適用し、補間計算。IKソルバで足などの最終姿勢を調整。
2.	剛体位置の事前更新: ボーン追従剛体について、この時点でBEPU上の剛体姿勢を対応ボーンの最新姿勢に合わせて更新。ボーンに追従するキネマティック剛体の位置・回転をセットします。こうすることで、例えば頭に追従する剛体は頭が動いた分だけ既に新位置におり、次の物理演算で髪の剛体との相対関係が正しくなります。
3.	物理ステップ実行: BEPUphysicsのシミュレーションを1ステップ進めます（例えば1/60秒分の更新）。必要に応じてサブステップを複数回回すことで安定性を向上させます。モバイルでは負荷と精度のトレードオフを考え、タイムステップやサブステップ数を調整します。
4.	結果の反映: 物理演算後、動的剛体の新しい位置・回転を取得し、それを対応するボーンに反映します（物理演算剛体の場合、関連ボーンが剛体の挙動に引っぱられる）[17]。具体的には各剛体に対応するボーンのローカル変換を、剛体のワールド変換に一致するよう更新します。物理+ボーン位置合わせフラグの剛体についても基本は同様ですが、必要に応じてジョイント制限を無視したズレを補正する処理を追加します。例えば剛体がジョイント範囲以上に外れてしまった場合でも、関連ボーンを剛体位置へスナップさせることで見かけ上破綻を防ぐことができます。
5.	頂点スキニングと描画: 最後に更新された各ボーンの姿勢に基づき、頂点を変形（スキニング）してモデルメッシュを描画します[9]。
この一連の流れを毎フレーム繰り返すことで、アニメーションと物理の連成が実現します。順序を間違えたり同期を怠ったりすると、物理が反映されなかったり不自然なラグが生じるため注意が必要です。
OpenTKとの座標系整合: なお、物理エンジンと描画エンジンで座標系（左手系/右手系）や軸の向きが異ならないよう統一することも重要です。MMDはDirectXベースで左手系と言われますが、Bullet Physicsは右手系を想定しているため、SabaSharpなど既存実装でも内部的には全て右手系で計算してOpenGL描画しています[29]。OpenTK(OpenGL)とBEPUphysics v2でも同様に、どちらかに合わせて座標系を統一してください。例えば右手系(Z軸前方)を採用するなら、モデル読み込み時に必要なら軸変換（例: +Yアップを+Zアップに変更 等）を一度だけ行い、以降は両ライブラリで整合した座標で扱います。座標変換の不一致は行列計算順序のバグや物理挙動のずれを招きやすいため、最初に確実に揃えておくのが賢明です[30][29]。
またBEPUphysics v2は独自の数値型（Vector3やQuaternion等）を持っています。OpenTKのMatrix4やVector3との間で頻繁に変換をするとオーバーヘッドになるため、必要に応じて暗黙的な型変換やユーティリティを用意すると開発がスムーズです[31][32]。BulletSharpにはOpenTKのMathクラスを直接利用できるビルドオプションがありましたが、BEPUでは自前のMathライブラリ（BepuUtilities）を使う設計になっているためです[31]。開発効率を上げるために変換演算子を定義したり、初期化時に両者の型を相互に変換するヘルパーを用意しておくと良いでしょう[32]。
OpenTK(OpenGL ES)による描画とデータ転送
頂点バッファとスキニング: モデルの頂点データ（位置・法線・UVなど）は、初期化時にOpenGLの頂点バッファオブジェクト(VBO)に転送しておきます。PMXでは多重ボーンスキニング（頂点に対する複数ボーンのウェイト）があるため、頂点ごとのボーンインデックスとウェイトもシェーダーに渡す必要があります。描画の際のスキニングには大きく2通りの方針があります:
•	GPUスキニング: ボーン行列の配列をユニフォームもしくはシェーダーStorage BufferとしてGPUに送り、頂点シェーダー内で各頂点の位置にボーン行列を適用する方法です。OpenGL ES 3.0ではある程度のユニフォーム配列長が許容されるため、中程度のボーン数（～数百）であればこの方法が取れます。GPUスキニングは頂点数が多い場合でもCPU-GPU間のデータ転送量が少なく、高速です。実際、前述のSabaSharpでも当初はCPU並列処理で頂点変形していましたが、後にOpenCLを用いたGPU側での並列計算に切り替えて高速化しています[4]。OpenGL ES環境ではOpenCL併用は難しいですが、シェーダー内計算で十分対応可能です。
•	CPUスキニング: 毎フレームCPU上で各頂点の位置をボーン姿勢に基づき更新し、glBufferSubData等でVBOに書き戻す方法です。実装が平易ですが、毎フレーム頂点数×16程度の浮動小数演算とメモリ転送が発生するため、モデルが高ポリゴンだと負荷が大きくなります。モバイル端末ではCPUパワーと帯域に限りがあるため、基本的にはGPUスキニングが推奨されます。ただしモデル規模が小さい場合や、実装を簡素化したい場合にはCPUスキニングでも動作させることはできます。その際はダブルバッファリング（描画中に次フレーム用バッファを書き換えても安全なようにVBOを2つ用意）や、glMapBufferRangeにGL_MAP_UNSYNCHRONIZED_BITを付けてノンブロッキング更新を行うなど、転送のボトルネックを緩和する工夫が有効です。
描画パイプライン: スキニング後の頂点データに対し、OpenGL ES 3.0の頂点シェーダー・フラグメントシェーダーでライティングやテクスチャ描画を行います。MMDモデル特有の描画要素として以下の点に注意します:
•	マテリアルと描画順: PMXマテリアルには透明度や描画順序、エッジ描画の有無などが設定されています。半透明マテリアルについてはブレンディングを有効にしつつ、描画順に注意します（奥から描いていないと透けないため）。基本的には不透明部分→エッジ→透明部分の順で描画し、描画順序による透け具合の不整合を防ぎます。
•	エッジ(輪郭線)描画: MMDモデルは描線輪郭によるアニメ風の縁取り表現があります。これは各マテリアルに対し「エッジサイズ」と「エッジ色」が設定されており、通常描画後にモデルを膨張させて描き直すことで実装できます[33]。具体的には、専用のエッジシェーダーで法線方向に頂点をエッジサイズ分だけ拡張し、裏面カリングを逆転させてシルエットのアウトラインを描画します（一般的な「輪郭線シェーダー」の手法）。OpenGL ESでもこの二重描画で十分実現可能ですが、ポリゴン数が倍になる点に注意してください。モバイルでは負荷増大となるため、必要に応じてエッジ描画を省略するオプションを設けることもあります。
•	シャドウ（影）描画: MMDにはステージ床面への簡易なシャドウ機能がありますが、独自エンジンで再現する場合、ライト方向に投影した影を床に描くなどの実装が考えられます。CNBlogsの例ではライトベクトルからシャドウ用行列を生成し、メッシュを床方向へ投影描画する方法が紹介されています[34]。モバイルGPU上でも簡単なマトリックス変換で対応可能ですが、この処理も追加の描画パスとなるためコストとの相談になります。
パフォーマンスとリソース管理: モバイル環境でネイティブにOpenGL ESを扱う場合、メモリとパフォーマンスに一層の注意が必要です。テクスチャは圧縮フォーマットを使う、頂点バッファは必要最低限のサイズに留める、使わないデータ（モーフターゲット等）は読み込まない等の対応でメモリ使用量を抑えます。また描画については頂点バッファをまとめてドローコール数を減らす（できるだけマテリアルごとにまとめて描画する）、glEnable(GL_CULL_FACE)で見えない面を描画しないようにする（ただしMMDモデルは両面描画前提のマテリアルも多いので注意）などの最適化も考慮します。
性能上の考慮点とよくある失敗例
物理演算の負荷と安定性: モバイル端末ではCPU性能に限りがあるため、必要以上に細かなサブステップや複雑な剛体は避けるべきです。BEPUphysics v2自体は高性能ですが、それでも剛体数や拘束が増えれば計算コストは上がります。幸い、BEPUphysicsはマルチスレッド並列計算に対応しており、Simulation構築時に並列ルーパーを指定することで複数スレッドでの物理更新が可能です[35]。端末のコア数に応じてスレッドを追加し、物理更新を並列化することでFPS低下を防げます[35]。もっとも、スレッドを増やすとシミュレーション結果の非決定性が増す（毎回全く同じ結果にならない）という特性もあります[36]。ネットワーク対戦などで厳密な再現性が必要な場合以外は問題になりませんが、デバッグ時に挙動がわずかに変わる可能性は念頭に置いてください。
シミュレーションが不安定（剛体が発散する、キャラクターが崩壊する等）な場合、以下を確認します: - 初期状態の干渉: モデル初期姿勢で剛体同士が重なりすぎていると、初回ステップで反発が大きく働き破綻しがちです。髪やスカートの剛体が体内部にめり込んで配置されている場合、BulletベースのMMD本家では内部で調整していますが、自前環境では初期数フレームは衝突判定を無視する、あるいは剛体位置を手動で少しずらしてやる、といった対策が有効です。数フレーム重力だけ適用して静止させてから衝突を有効にすることで、急激な跳ねを和らげます。 - パラメータ調整: 剛体の質量比が極端だと、軽い剛体が重い剛体に押し負けて挙動が飛びやすくなります。MMDモデルでは髪や服は質量0.5～5程度、体幹は20～50程度など比較的近い値で設計されていることが多いです。もし独自モデルで質量設定して不安定なら、重すぎるもの・軽すぎるものを調整します。また減衰値（空気抵抗的なもの）を適度に高めると振動が収まり安定します[37]。例えば0に近い減衰だとヒンジで無限振動することもありますが、0.98程度に上げれば収束が速まります[37]。 - サブステップ増加: どうしても高速な動きで衝突をすり抜ける場合（例えばキャラが瞬間移動して布がすり抜ける）、物理エンジンの更新頻度を上げる（1フレーム内で2回シミュレーション更新する等）ことで改善できます。ただしCPU負荷と相談です。
描画パフォーマンス: 描画面では、シェーダーの最適化や描画負荷の分散も考えます。モバイルGPUはデスクトップよりシェーダー性能が低いため、頂点シェーダー内でのスキニング計算はボーン数・頂点数次第ではボトルネックになります。必要であればボーンの影響を受ける頂点だけを計算するよう工夫したり、影響のない部分は静的メッシュに分離することも手です。また、頂点バッファやテクスチャ転送は極力初期化時に済ませ、毎フレーム送るデータは最小限にしましょう。Uniformバッファにまとめて送信できるデータはまとめ、複数のglDrawをまたぐような状態変更は減らします。
データ変換のバグ: 自作実装で起こりがちな不具合として、ボーン行列の適用ミスや座標変換ミスがあります。例えばボーンの初期姿勢オフセットを無視すると、モデルがTポーズから動かなかったりバラバラに崩れます。PMXのボーンは初期姿勢のオフセット行列を持つため、親ボーンから順に行列を積算する際には各ボーンの初期オフセットを考慮したワールド行列を計算します。これを忘れると子ボーンが原点周りに回転してしまい不自然になります。IKの実装ミスも多いポイントで、関節の可動範囲制限を入れないと膝が逆方向に曲がる逆関節問題が発生します[38][39]。MMDのIK設定には膝が自然に曲がる方向も記録されている（PMXのボーンに「ひざボーンは+X回転のみ可」といったフラグ）ので、CCDソルバ実装時にその軸制限を反映させる必要があります[40]。
最後に、開発中はデバッグ表示を活用すると良いでしょう。物理剛体の当たり判定形状をワイヤーフレームで表示したり、ボーンの位置を可視化することで、不具合箇所を特定しやすくなります。BEPUphysics v2にはデモ用の描画ユーティリティがありますし[27]、OpenTKでもライン描画で簡易的に表現可能です。
おわりに
OpenTK + PMXParser + BEPUphysics v2を組み合わせたMMD再現は、モデルデータ構造の把握から物理エンジン統合、描画最適化まで幅広い知見が要求されます。しかし、既存の事例[1][4]やMMD仕様のドキュメント[18]を参考に各要素を丁寧に実装・調整すれば、モバイル上でも十分にMMDライクなアニメーションを実現できます。特に物理演算の同期タイミングとデータ形式の整合に注意を払い、段階的に検証しながら進めることが成功への近道です。実装の途中で直面する問題も、本稿で述べたようなポイントを確認することで解決の糸口が見つかるでしょう。モデルが生き生きと踊り、髪や服が自然に揺れる様子をモバイル端末で再現できたときには、大きな達成感が得られるはずです。
参照資料: MMD関連オープンソース実装[1][4]、MMD4Mecanim/Unity資料[18]、物理エンジン技術情報[31][32]、他上記リンク先。各リンク先で示されたコードフローや設定値を基に、実装を進めてください。
________________________________________
[1] [2] [3] C++でMMDを読み込むライブラリを作った #3D - Qiita
https://qiita.com/benikabocha/items/ae9d48e314f51746f453
[4] [6] GitHub - qian-o/SabaSharp: mmd播放器
https://github.com/qian-o/SabaSharp
[5] [8] [9] [10] [33] [34] 〖NET 7.0、OpenGL ES〗使用Silk.NET渲染MMD，并实时进行物理模拟。 - o王先生o - 博客园
https://www.cnblogs.com/xymfblogs/p/17712441.html
[7] [27] bepu/bepuphysics2: Pure C# 3D real time physics ... - GitHub
https://github.com/bepu/bepuphysics2
[11] [12] [13] [14] [38] [39] [40] 私は初音ミクに会いたかった #dlang - Qiita
https://qiita.com/ottu/items/a393e5d06c5253b8c724
[15] [16] [17] [18] [19] [20] [21] [22] [23] [24] [25] [28] [37] 剛体とジョイントの構成要素 - MMDモデル物理セットアップ wiki - atwiki（アットウィキ）
https://w.atwiki.jp/mmdphysics/pages/16.html
[26] Joints and Constraints - BEPUphysics
https://bepuphysics6.rssing.com/chan-6590298/all_p1.html
[29] [30] MMDの再生、物理演算いれてみた – すらりん日記
https://blog.techlab-xe.net/mmd%E3%81%AE%E5%86%8D%E7%94%9F%E3%80%81%E7%89%A9%E7%90%86%E6%BC%94%E7%AE%97%E3%81%84%E3%82%8C%E3%81%A6%E3%81%BF%E3%81%9F/
[31] [32] Using BEPU with OpenTK - BEPUphysics
https://forum.bepuentertainment.com/viewtopic.php?t=2284
[35] [36] 〖BEPU V1物理〗多线程加速物理模拟 汉化笔记#5_物理模拟中使用多线程计算-CSDN博客
https://blog.csdn.net/qq_41094072/article/details/147200030
